#!/usr/bin/env node

var fs         = require('fs');
var path       = require('path');
var RSVP       = require('rsvp');
var glob       = require('glob');
var del        = require('del');
var exec       = require('child_process').exec;
var argv       = require('minimist')(process.argv.slice(2));

var fopen  = RSVP.denodeify(fs.open);
var fread  = RSVP.denodeify(fs.readFile);
var globp  = RSVP.denodeify(glob);

var MODE     = argv.mode || (argv.p ? 'prod' : 'dev');
var buildAll = argv.all || argv.a || false;
var verbose  = argv.verbose || argv.v || false;

console.log( '------------------------ Building ------------------------');
console.log( ' options: ', argv );
console.log( ' MODE(', MODE, ') build all(', buildAll, ') verbose (', verbose, ') ' );
console.log( '----------------------------------------------------------');


build();

function build() {

  var promise;

  if( buildAll ) {

    promise =  clean()
              .then( () =>  commonBuild() )
              .then( () => RSVP.all(_allBuilders()) );

  } else {
    promise = commonBuild();
  }

  promise
    .then( () => console.log('build done') )
    .catch( errr => { err(errr) } );    

}

function commonBuild() {  

  return lintSource()
          .then( () => RSVP.all(_commonBuilders()) )
          .then( () => MODE === 'prod' ? minifyDist() : undefined );
}

function _commonBuilders() {
  return [ 
    bundleAppCSSFiles(),
    publishPublicFiles(),
    generateRouteIndex(),
    generateComponentIndex(),
    publishServerLibrary(),
    bundleBrowserJS()
  ];
}

function clean() {
  return del( ['dist/**/*', 'built/**/*'] ).then( () => mkdir('dist') );
}

function _allBuilders() {
  return [ 
      bundleVendorJSFiles(), 
      bundleVendorCSSFiles(), 
      publishFontFiles(),
      publishSMFiles(),
    ];  
}

function generateIndexJS(dir,formatter) {
  var str = "// this file is generated by the build process \n\n" +
            "module.exports = { \n"
  return del( './app/'+dir+'/index.js' )
    .then( function() {
      return globp('./app/'+dir+'/*');
    }).then( function(files) {
      files.forEach( f => {
        var name = path.parse(f).name;
        var rname = formatter(name);
        str += "  " + rname + ": require('./" + name + "'),\n";
      });
      str += "\n};\n\n";
      log('writing '+dir+'/index.js');
      fs.writeFileSync( './app/'+dir+'/index.js', str, 'utf8' );
    });
}

function generateRouteIndex() {
  return generateIndexJS('routes', n => n.replace(/-?(r|R)oute$/,''));
}

function generateComponentIndex() {
  return generateIndexJS('components', n => n);
}

function lintSource() {
  log('invoking lint');
  return execp('eslint app');
}

function publishServerLibrary() {
  log('spawing babel for server libs')
  var cmd = 'babel app --out-dir built';
  return execp(cmd).then( stdout => log( 'Babel output: ', stdout) );
}

function minifyDist() {
  log('spawing uglify for dist js/css')
  var cssCmd = 'uglify -s dist/css/app.css -o dist/css/app.css -c';
  var jsCmd  = 'uglify -s dist/js/bundle.js -o dist/js/bundle.js';
  return execp(cssCmd).then( () => execp( jsCmd ) );
}

function publishPublicFiles() {

  mkdir('dist/images');

  return globp('public/{*.html,images/*.*}')
    .then( fnames => fnames.forEach( f => copy( f, f.replace('public/','dist/') ) ) );
}

function bundleAppCSSFiles() {
  return globp( 'public/css/*.css' )
    .then( files => bundleAppFiles(files,'css') );
}

function bundleBrowserJS() {
  log('creating bundle.js');
  mkdir('dist/js');

  var cmd = 'browserify app/**/*.js -e app/browser.js  -t babelify --noparse=http -u http -u stream-http ';
  if( MODE === 'dev') {
    cmd += " --full-paths ";
  }
  cmd += "-o dist/js/bundle.js";

  return execp(cmd);
}

function bundleVendorJSFiles() {  
  
  // soundmanager with debug is very noisy
  
  var vendorJSSources = {
    dev: [
        'node_modules/jquery/dist/jquery.js',
        'node_modules/bootstrap/dist/js/bootstrap.js',
        'node_modules/soundmanager2/script/soundmanager2-nodebug.js'
        ],
    prod: [
        'node_modules/jquery/dist/jquery.min.js',
        'node_modules/bootstrap/dist/js/bootstrap.min.js',
        'node_modules/soundmanager2/script/soundmanager2-nodebug-jsmin.js'
    ]
  };
  return bundleVendorFiles(vendorJSSources[MODE],'js');
}

function publishFontFiles() {

  mkdir('dist/fonts');

  var rootd = 'node_modules/font-awesome/';

  return publishDir(rootd + 'fonts/*.*', rootd );
}

function publishSMFiles() {

  mkdir('dist/swf');

  var rootd = 'node_modules/soundmanager2/';

  return publishDir( rootd + 'swf/soundmanager2{_flash9.swf,.swf}' ,rootd);
}

function publishSourceMaps() {

  mkdir('dist/fonts');

  if( MODE === 'dev' ) {

    var fromTos = [
      {
        from: 'node_modules/bootstrap/dist/css/bootstrap-theme.css.map',
        to: 'dist/css/bootstrap-theme.css.map'
      }
    ];

    fromTos.forEach( ft => copy(ft.from, ft.to) );
  }
}

function bundleVendorCSSFiles() {

  var vendorCSSSources = {
    dev: [
      'node_modules/bootstrap/dist/css/bootstrap.css',
      'node_modules/bootstrap/dist/css/bootstrap-theme.css',
      'node_modules/font-awesome/css/font-awesome.css',
    ],
    prod: [
      'node_modules/bootstrap/dist/css/bootstrap.min.css',
      'node_modules/bootstrap/dist/css/bootstrap-theme.min.css',
      'node_modules/font-awesome/css/font-awesome.min.css',
    ]
  };
  return bundleVendorFiles(vendorCSSSources[MODE],'css');
}

function publishDir(files,rootd) {
  return globp( files )
    .then( fnames => fnames.forEach( f => copy( f, f.replace(rootd,'dist/') ) ) );
}

function bundleVendorFiles(arr,outext) {
  var dir = 'dist/' + outext;
  mkdir(dir);
  return bundleFiles(arr, dir + '/vendor.' + outext);
}

function bundleAppFiles(arr,outext) {
  // should be uglify step here
  var dir = 'dist/' + outext;
  mkdir(dir);
  return bundleFiles(arr, dir + '/app.' + outext);
}

function bundleFiles(arr,destination) {
  var fd = null;

  log( 'creating bundle ', destination, arr );

  return fopen(destination, 'w')
    .then( function(fileDescriptor) {
        fd = fileDescriptor;
        var promises = arr.map( n => fread(n,'utf8') );
        return RSVP.all(promises);
      })
    .then( function(datas) {
        fs.write(fd,datas.join("\n/* ccmbuildjoint */\n"));
        fs.close(fd);
      })
    .catch( err );
}

function copy(src,dest) {
  if( verbose ) {
    log('copying ', dest);
  }
  fs.createReadStream(src)
    .on('error', err )
    .pipe(fs.createWriteStream(dest))
}

function err(err) {
  console.log("Error : " + err.message);
  process.exit(1);
}

function mkdir( dir ) {
  try { 
    fs.mkdirSync(dir); 
    log('created directory', dir);
  } catch(e) { }
}

function log() {
  if( verbose ) {
    console.log.apply(console.log,arguments);
  }
}

function execp(cmd)
{
  return new RSVP.Promise( function(success,reject) {
    exec(cmd,function(err, stdout, stderr) {
      if( err ) {
        console.log(stdout);
        reject(err);
      } else {
        log( 'Result from: ', cmd.split(/\s+/)[0], stdout || '(empty)');
        success(stdout);
      }
    });
  });
}
